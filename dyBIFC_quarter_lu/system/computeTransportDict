computeTransport
{
        functionObjectLibs ( "libutilityFunctionObjects.so" );
        enabled         true;
        type            coded;
        redirectType    computeTransport;
        outputControl   outputTime;

        codeOptions
        #{
            -I$(LIB_SRC)/meshTools/lnInclude
        #};

        code
        #{
	    const volVectorField& UMean = mesh().lookupObject<volVectorField>("UMean");
	    const volVectorField& UPrime = mesh().lookupObject<volVectorField>("UPrime");
	    const volSymmTensorField& UPrime2Mean = mesh().lookupObject<volSymmTensorField>("UPrime2Mean");
	    const volScalarField& pPrime = mesh().lookupObject<volScalarField>("pPrime");
	    const volScalarField& nu = mesh().lookupObject<volScalarField>("nu");
	    //const volScalarField& k_mem = 0.5*tr(UPrime2Mean);
	    volScalarField k_mem = 0.5 * tr(UPrime2Mean);
	    static autoPtr<volScalarField> sField;
	    static autoPtr<volScalarField> ssField;
	    static autoPtr<volScalarField> sssField;
	    static autoPtr<volScalarField> ssssField;
	    
	    //Info << " max nu " << max(nu) << nl;
	    //Info << " min nu " << min(nu) << nl;

	    if(!sField.valid())
	    {
	        sField.set
      	        (
                    new volScalarField
                    (
            		IOobject
            		(
               		    "kVisTrans",
               		    mesh().time().timeName(),
               		    UPrime.mesh(),
               		    IOobject::NO_READ,
               		    IOobject::AUTO_WRITE
            		),
	        	//(UPrime & UPrime) * dimensionedScalar("tmp", dimensionSet(0, 0, -1, 0, 0, 0, 0), 1)
	                //dimensionedScalar("nu", dimensionSet(0, 2, -1, 0, 0, 0, 0), 1e-5) * fvc::div(fvc::grad(k_mem))
	                nu * fvc::div(fvc::grad(k_mem))
                    )
      	        );
	    }

	    if(!ssField.valid())
	    {
		ssField.set
      		(
         	    new volScalarField
         	    (
            		IOobject
            		(
               		    "kPreTrans",
               		    mesh().time().timeName(),
               		    UPrime.mesh(),
               		    IOobject::NO_READ,
               		    IOobject::AUTO_WRITE
            		),
			//pPrime * dimensionedScalar("tmp", dimensionSet(0, 0, -1, 0, 0, 0, 0), 1)
	                 -fvc::div(pPrime * UPrime)
         	    )
      		);
	    }

	    if(!sssField.valid())
	    {
		sssField.set
      		(
         	    new volScalarField
         	    (
            		IOobject
            		(
               		    "kTurTrans",
               		    mesh().time().timeName(),
               		    UPrime.mesh(),
               		    IOobject::NO_READ,
               		    IOobject::AUTO_WRITE
            		),
			//(UPrime & UPrime) * dimensionedScalar("tmp", dimensionSet(0, 0, -1, 0, 0, 0, 0), 1)
	                //-fvc::div(0.5 * tr(UPrime2Mean) * UPrime)
	   		-fvc::div(UPrime * 0.5*(UPrime & UPrime))
         	    )
      		);
	    }

	    if(!ssssField.valid())
	    {
	        ssssField.set
      	        (
         	    new volScalarField
                    (
            		IOobject
            		(
               		    "kAdv",
               		    mesh().time().timeName(),
               		    UPrime.mesh(),
               		    IOobject::NO_READ,
               		    //IOobject::NO_WRITE
               		    IOobject::AUTO_WRITE
            		),
	                 -(UMean & fvc::grad(k_mem))
	        	 //UPrime * dimensionedScalar("tmp", dimensionSet(0, 2, -2, 0, 0, 0, 0), 1)
                    )
      	        );
	    }

	    // TKE viscous transport
	    volScalarField kTmp = 0.5 * tr(UPrime2Mean);
	    //volTensorField UPrimeGrad = fvc::grad(UPrime);
	    //volVectorField UPrimeSij = -1 * dimensionedScalar("nu", dimensionSet(0, 2, -1, 0, 0, 0, 0), 1e-5) * (UPrime & (UPrimeGrad + UPrimeGrad.T())) ;
	    volScalarField &kVisTrans = sField();
	    kVisTrans.checkIn();
	    //kVisTrans = -fvc::div(UPrimeSij);
	    kVisTrans =  nu * fvc::div(fvc::grad(kTmp));

	    // TKE pressure transport
	    volScalarField &kPreTrans = ssField();
	    kPreTrans.checkIn();
	    kPreTrans = -fvc::div(pPrime * UPrime);

	   // TKE turbulent transport
	   volScalarField &kTurTrans = sssField();
	   kTurTrans.checkIn();
	   //kTurTrans = -fvc::div(kTmp * UPrime);
	   kTurTrans = -fvc::div(UPrime * 0.5*(UPrime & UPrime));

	   // TKE advection
	   volScalarField &kAdv = ssssField();
	   kAdv.checkIn();
	   kAdv = -(UMean & fvc::grad(kTmp));

	#};
}
