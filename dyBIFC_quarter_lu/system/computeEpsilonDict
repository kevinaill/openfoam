    computeEpsilon
    {
        functionObjectLibs ( "libutilityFunctionObjects.so" );
        enabled         true;
        type            coded;
        redirectType    computeEpsilon;
        //writeControl    writeTime;
        //outputControl   timeStep;
        //outputInterval  5;
        outputControl   outputTime;

        codeOptions
        #{
            -I$(LIB_SRC)/meshTools/lnInclude
        #};

        code
        #{
	    const volVectorField& UPrime = mesh().lookupObject<volVectorField>("UPrime");
	    const volScalarField& nu = mesh().lookupObject<volScalarField>("nu");
	    static autoPtr<volScalarField> sField;
	    
	    if(!sField.valid())
	    {
		sField.set
      		(
         	    new volScalarField
         	    (
            		IOobject
            		(
               		    "epsilon",
               		    mesh().time().timeName(),
               		    UPrime.mesh(),
               		    IOobject::NO_READ,
               		    IOobject::AUTO_WRITE
            		),
			//(UPrime & UPrime) * dimensionedScalar("tmp", dimensionSet(0, 0, -1, 0, 0, 0, 0), 1)
	                -1 * nu * (fvc::grad(UPrime) && fvc::grad(UPrime))
         	    )
      		);
	    }
	    
	    //volTensorField UPrimeGrad = fvc::grad(UPrime);
	    volScalarField &epsilon = sField(); 
	    epsilon.checkIn();
	    //epsilon = -2 * dimensionedScalar("nu", dimensionSet(0, 2, -1, 0, 0, 0, 0), 1e-5) * (0.5 * (UPrimeGrad + UPrimeGrad.T())) && (0.5 * (UPrimeGrad + UPrimeGrad.T()));
	    epsilon = -1 * nu * (fvc::grad(UPrime) && fvc::grad(UPrime));
       #};
    }
